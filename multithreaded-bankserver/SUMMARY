SUMMARY

Given my goal for the previous project, a basic shell, was to maximize reusability through proper modularity, I would claim success on reusing the command parsing and linked list implementations. Adding locking support was fairly easy with pthreads. The real meat of this project was in writing the worker threads which handled reading from and updating accounts. For this I chose to separate out transactions and checks as separate files which defined functions for creating the respective transactions on the main input thread and for processing them from worker threads.

My goal was to learn something new, and given my previous exploration with mutex locks and pthread_cond_wait I wanted something new. I briefly considered using a per-account read-write lock to allow concurent reads and independent transactions to complete. I'm still convinced this could have been implemented, but even more real-world, challenging and thus interesting was to take a page from the book of NoSQL implementations and implement a pseudo vector-clock. For way of a simple explanation, each account had a read and write clock which started at zero. A check would increment the read clock and record the write clock in the request, while a transaction would increment the read clock and set the write clock to this new clock value for each relevant account, also storing these values in the request. Thus each request contained the "version" at which it expects its accounts to be at in order to be processed. This means that we can attempt requests in any order, but they will only successfully run and increment the account version when all previously queued transactions / checks have completed.

Both coarse and fine grained locking gave me exactly the same run times, likely as per-account locking is implicit in my account clock implementation, so there was almost no difference in the fine and coarse grained locking code. I hypothesize that a per-account mutex lock would give somewhat better results in fine mode because transactions that do not depend on the same account would still have the chance to run concurently. If instead a lock was used per group of accounts, I conjecture the run time would be between the fine and coarse because the fine grained locking is probably the fastest possible implementation. It allows the maximum ammout of concurrency, and in reality the pthreads mutex implmentation runs in userspace, only using expesive kernel calls in the case of a direct conflict. However, none of this is overly relevant to my implementation. I focused on a real-world implemntation that was scalable, distributable and resiliant. Perhaps I lost some performance against a pure mutex-locking implementation, but I'm still very happy with the final result. Since the majority of the execution time is spent waiting on account access and I run at maximum parallelization, it is doubtful any implementation would be more than marginally faster.
